#!/usr/bin/env python
import copy
import argparse
import sys

import numpy as np
from nipype.algorithms import icc

import rapidtide.io as tide_io
import rapidtide.util as tide_util
from rapidtide.workflows.parser_funcs import is_valid_file

def _get_parser():
    parser = argparse.ArgumentParser(
        prog="calcicc",
        description="Calculate per-voxel ICC(3,1) on a set of nifti files.",
        usage="%(prog)s datafile outputroot [options]",
    )

    # Required arguments
    parser.add_argument(
        "datafile",
        type=lambda x: is_valid_file(parser, x),
        help="The name of the 4 dimensional nifti file.",
    )
    parser.add_argument("outputroot", help="The root name for the output nifti files.")

    # Optional arguments
    parser.add_argument(
        "--dmask",
        dest="datamaskname",
        type=lambda x: is_valid_file(parser, x),
        action="store",
        metavar="DATAMASK",
        help=("Use DATAMASK to specify which voxels in the data to use."),
        default=None,
    )

    return parser

def main():
    try:
        args = _get_parser().parse_args()
    except SystemExit:
        _get_parser().print_help()
        raise


    nummeas = 2
    datafile = args.datafile

    # read in data
    print("reading in data arrays")
    (
        datafile_img,
        datafile_data,
        datafile_hdr,
        datafiledims,
        datafilesizes,
    ) = tide_io.readfromnifti(datafile)
    print("done reading in data array")

    xsize, ysize, numslices, timepoints = tide_io.parseniftidims(datafiledims)

    if args.datamaskname is not None:
        print("reading in mask array")
        (
            datamask_img,
            datamask_data,
            datamask_hdr,
            datamaskdims,
            datamasksizes,
        ) = tide_io.readfromnifti(args.datamaskname)
        if not tide_io.checkspacematch(datafile_hdr, datamask_hdr):
            print("Data and mask dimensions do not match - exiting.")
            sys.exit()
        print("done reading in mask array")
    else:
        datamask_data = datafile_data[:, :, :, 0] * 0.0 + 1.0

    # now reformat from x, y, z, time to voxelnumber, measurement, subject
    numvoxels = int(xsize) * int(ysize) * int(numslices)
    numsubjs = int(timepoints // nummeas)

    print("reshaping to voxel by timepoint")
    data_in_voxacq = datafile_data.reshape((numvoxels, timepoints))
    mask_in_vox = datamask_data.reshape((numvoxels))

    print("finding valid voxels")
    validvoxels = np.where(mask_in_vox > 0)[0]
    numvalid = int(len(validvoxels))
    valid_in_voxacq = data_in_voxacq[validvoxels, :]

    print("reshaping to validvox by nummeas by numsubjects")
    validinvms = valid_in_voxacq.reshape((numvalid, nummeas, numsubjs))
    print(validinvms.shape)

    ICC_in_valid = np.zeros((numvalid), dtype=float)
    r_var_in_valid = np.zeros((numvalid), dtype=float)
    e_var_in_valid = np.zeros((numvalid), dtype=float)

    print("calculating ICC")
    reportstep = 100
    for voxel in range(numvalid):
        if voxel % reportstep == 0 or voxel == numvalid - 1:
            tide_util.progressbar(
                voxel + 1,
                numvalid,
                label="Percent complete",
            )
        (
            ICC_in_valid[voxel],
            r_var_in_valid[voxel],
            e_var_in_valid[voxel],
            session_effect_F,
            dfc,
            dfe,
        ) = icc.ICC_rep_anova(np.transpose(validinvms[voxel, :, :]))

    outarray_in_vox = mask_in_vox * 0.0

    theheader = copy.deepcopy(datafile_hdr)
    theheader["dim"][0] = 3
    theheader["dim"][4] = 1

    outarray_in_vox[validvoxels] = ICC_in_valid[:]
    tide_io.savetonifti(
        outarray_in_vox.reshape(xsize, ysize, numslices), theheader, f"{args.outputroot}_ICC"
    )
    outarray_in_vox[validvoxels] = r_var_in_valid[:]
    tide_io.savetonifti(
        outarray_in_vox.reshape(xsize, ysize, numslices), theheader, f"{args.outputroot}_r_var"
    )
    outarray_in_vox[validvoxels] = e_var_in_valid[:]
    tide_io.savetonifti(
        outarray_in_vox.reshape(xsize, ysize, numslices), theheader, f"{args.outputroot}_e_var"
    )


if __name__ == "__main__":
    main()
