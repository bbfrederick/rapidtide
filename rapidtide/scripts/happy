#!/usr/bin/env python
#
#   Copyright 2016 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# $Author: frederic $
#       $Date: 2016/07/11 14:50:43 $
#       $Id: showxcorr,v 1.41 2016/07/11 14:50:43 frederic Exp $
#
from __future__ import print_function, division

import time
import warnings
import sys
import os
import platform

import numpy as np
import scipy as sp

import getopt
import rapidtide.tide_funcs as tide
import rapidtide.util as tide_util
import rapidtide.io as tide_io
import rapidtide.filter as tide_filt
import rapidtide.fit as tide_fit
import rapidtide.resample as tide_resample
from scipy.signal import hilbert, welch, savgol_filter
import nibabel as nib

from pylab import plot, legend, show, figure


def usage():
    print(os.path.basename(sys.argv[0]), "- Hypersampling by Analytic Phase Projection - Yay!")
    print("")
    print("usage: ", os.path.basename(sys.argv[0]), " fmrifile slicetimefile outputroot")
    print("")
    print("required arguments:")
    print("    fmrifile:                 nifti file containing BOLD fmri data")
    print("    sampletimefile:           text file containing the offset time in seconds of each slice relative to the start of the TR,")
    print("                              one value per line, OR the BIDS sidecar JSON file for the fmrifile (contains the SliceTiming field")
    print("    outputroot:               base name for all output files")
    print("")
    print("optional arguments:")
    print("    --glm                      - generate voxelwise aliased synthetic cardiac regressors and filter them out")
    print("    --minhr=MINHR              - highpass filter cardiac data to MINHR BPM (default is 180.0)")
    print("    --maxhr=MAXHR              - lowpass filter cardiac data to MAXHR BPM (default is 36.0)")
    print("    --notchwidth=WIDTH         - Set the width of the notch filter, in percent of the notch frequency (default is 1.5)")
    print("    --outputbins=BINS          - number of output phase bins (default is 32)")
    print("    --gridbins=BINS            - width of the gridding kernel in output phase bins (default is 1.5)")
    print("    --cardiacfile=FILE[:COL]   - Read the cardiac waveform from file FILE.  If COL is an integer,")
    
    print("                                 format json file, use column named COL (if no file is specified ")
    print("                                 is specified, estimate cardiac signal from data)")
    print("    --cardiacfreq=FREQ         - Cardiac waveform in cardiacfile has sample frequency FREQ ")
    print("                                 (default is 32Hz). NB: --cardiacfreq and --cardiactstep")
    print("                                 are two ways to specify the same thing")
    print("    --cardiactstep=TSTEP       - Cardiac waveform in file has sample time step TSTEP ")
    print("                                 (default is 0.03125s) NB: --cardiacfreq and --cardiactstep")
    print("                                 are two ways to specify the same thing")
    print("    --cardiacstart=START       - The time delay in seconds into the cardiac file, corresponding")
    print("                                 in the first TR of the fmri file (default is 0.0)")
    print("")
    print("debugging arguments (probably not of interest to users)")
    print("    --debug                    - turn on debugging information")
    print("    --nodetrend                - disable data detrending")
    print("    --normalize                - normalize fmri data")
    print("    --disablenotch             - disable subharmonic notch filter")

    return ()


def phasemod(phase):
    return np.fmod(np.pi + phase, 2.0 * np.pi) - np.pi


def rrifromphase(timeaxis, thephase):
    return None


def setnotchfilter(thefilter, thefreq, notchwidth=0.01):
    thefilter.settype('arb_stop')
    thefilter.setarb( \
        thefreq * (1.0 - notchwidth/2.0), \
        thefreq * (1.0 - notchwidth/2.0), \
        thefreq * (1.0 + notchwidth/2.0), \
        thefreq * (1.0 + notchwidth/2.0))


def cardiacsig(thisphase, amps=[1.0, 0.0, 0.0], phases=None, overallphase=0.0):
    total = 0.0
    if phases is None:
        phases = amps * 0.0
    for i in range(len(amps)):
        total += amps[i] * np.cos((i + 1) * thisphase + phases[i] + overallphase)
    return total


def cardiacfromimage(imbyvox, maskbyvox, xsize, ysize, numslices, timepoints, tr, slicetimes, initprefilter, notchwidth=0.015, detrend=True, debug=False):

    # normalize every voxel over time
    normdata = imbyvox * 0.0
    validvoxels = np.where(maskbyvox > 0)[0]
    for spatialloc in validvoxels:
        if detrend:
            normdata[spatialloc, :] = tide.pcnormalize(tide_fit.detrend(imbyvox[spatialloc, :], demean=False))
        else:
            normdata[spatialloc, :] = tide.pcnormalize(imbyvox[spatialloc, :])
    normbyslice = normdata.reshape((xsize * ysize, numslices, timepoints))

    sortedtimes = np.sort(slicetimes)
    diffs = sortedtimes[1:] - sortedtimes[0:-1]
    minstep = np.max(diffs)
    numsteps = int(np.round(tr / minstep, 0))
    sliceoffsets = np.around(slicetimes / minstep).astype(np.int32) % numsteps
    print(len(slicetimes), 'slice times with', numsteps, 'unique values - diff is', minstep)
    
    # make slice means
    hirestc = np.zeros((timepoints * numsteps), dtype=np.float64)
    sliceavs = np.zeros((numslices, timepoints), dtype=np.float64)
    for theslice in range(numslices):
        sliceavs[theslice, :] = np.mean(normbyslice[:, theslice, :], axis=0)
        for t in range(timepoints):
            hirestc[numsteps * t + sliceoffsets[theslice]] += sliceavs[theslice, t]
    slicesamplerate = 1.0 * numsteps / tr
    print('slice sample rate is ', slicesamplerate)
    filthirestc = -1.0 * tide.corrnormalize(initprefilter.apply(slicesamplerate, hirestc), False, False)

    # delete the TR frequency and the first subharmonic
    maxpass = np.min([slicesamplerate / 2.0, initprefilter.getfreqlimits()[2]])
    if notchwidth > 0.0:
        stopfreq = 1.0 / tr
        maxharmonic = int(maxpass // stopfreq)
        print('highest harmonic is', maxharmonic, '(', maxharmonic * stopfreq, 'Hz)')
        trnotchfilter = tide_filt.noncausalfilter(debug=debug)
        for harmonic in range(1, maxharmonic + 1):
            print('removing harmonic at', harmonic * stopfreq)
            setnotchfilter(trnotchfilter, harmonic * stopfreq, notchwidth=notchwidth)
            filthirestc = trnotchfilter.apply(slicesamplerate, filthirestc)

    return filthirestc, slicesamplerate, numsteps


def savgolsmooth(data, smoothlen=301, polyorder=3):
    return savgol_filter(data, smoothlen, polyorder)


def getcardcoeffs(cardiacwaveform, slicesamplerate, smoothlen=301, debug=False):
    if len(cardiacwaveform) > 1024:
        thex, they = welch(cardiacwaveform, slicesamplerate, nperseg=1024)
    else:
        thex, they = welch(cardiacwaveform, slicesamplerate)
    print('initpeakfreq:', np.round(thex[np.argmax(they)] * 60.0, 2), 'BPM')
    spectrum = sp.fftpack.fft(tide_filt.hamming(len(cardiacwaveform)) * cardiacwaveform)[0:len(cardiacwaveform) // 2]
    smoothspectrum = savgolsmooth(spectrum.real, smoothlen=smoothlen) + savgolsmooth(spectrum.imag, smoothlen=smoothlen) * 1.0j
    if debug:
        tide_io.writevec(spectrum.real, 'spectrum.txt')
        tide_io.writevec(smoothspectrum.real, 'smoothspectrum.txt')
    ampspec = np.abs(smoothspectrum)
    phasespec = np.angle(smoothspectrum)
    maxfreq = slicesamplerate / 2.0
    freqaxis = sp.linspace(0.0, maxfreq, len(ampspec), endpoint=False)
    if debug:
        figure()
        plot(freqaxis, ampspec, 'r')
        show()
    peakfreq = freqaxis[np.argmax(ampspec)]
    print('cardiac fundamental frequency is', np.round(peakfreq * 60.0, 2), 'BPM')
    normfac = np.sqrt(2.0) * tide.rms(cardiacwaveform)
    print('normfac:', normfac)
    amps = []
    amps.append(normfac)
    amps.append(normfac * ampspec[2 * np.argmax(ampspec)] / ampspec[np.argmax(ampspec)])
    amps.append(normfac * ampspec[3 * np.argmax(ampspec)] / ampspec[np.argmax(ampspec)])
    phases = []
    phases.append(0.0)
    phases.append(phasespec[2 * np.argmax(ampspec)] - phasespec[np.argmax(ampspec)])
    phases.append(phasespec[3 * np.argmax(ampspec)] - phasespec[np.argmax(ampspec)])

    return peakfreq, amps, phases


# get the command line parameters
debug = False
dofilter = False
fmrinorm = False
histlen = 100
doplot = False
smoothlen = 301
maskthreshpct = 10.0
upsamplefac = 100
destpoints = 32
congridbins = 1.5
cardiacfile = None
colnum = 0
colname = None
inputrate = 32.0
inputstart = 0.0
doglm = False
detrend = True
notchwidth = 0.015
arb_lower = 0.6
arb_upper = 3.0
softvesselfrac = 0.4
infodict = {}

# start the clock!
timings = [['Start', time.time(), None, None]]

print("***********************************************************************************************************************************")
print("NOTICE:  This program is NOT released yet - it's a work in progress and is nowhere near done.  That's why")
print("there's no documentation or mention in the release notes.  If you want to play with it, be my guest, but be")
print("aware of the following:")
print("    1) Any given version of this prgram may or may not work, or may work in a way different than ")
print("       a) previous versions, b) what I say it does, c) what I think it does, and d) what you want it to do.")
print("    2) I am intending to write a paper on this, and if you take this code and scoop me, I'll be peeved. That's just rude.")
print("    3) For all I know this program might burn down your house, leave your milk out of the refrigerator, or ")
print("       poison your dog.  USE AT YOUR OWN RISK.")
print("***********************************************************************************************************************************")
print("")

nargs = len(sys.argv)
if nargs < 4:
    usage()
    exit()
fmrifilename = sys.argv[1]
slicetimename = sys.argv[2]
outputroot = sys.argv[3]

infodict['fmrifilename'] = fmrifilename
infodict['slicetimename'] = slicetimename
infodict['outputroot'] = outputroot

tide_util.savecommandline(sys.argv, outputroot)

# now scan for optional arguments
try:
    opts, args = getopt.getopt(sys.argv[4:], "x", ["cardiacfile=",
                                                     "cardiacfreq=",
                                                     "cardiactstep=",
                                                     "cardiacstart=",
                                                     "maxhr=",
                                                     "minhr=",
                                                     "notchwidth=",
                                                     "disablenotch",
                                                     "nodetrend",
                                                     "glm",
                                                     "debug",
                                                     "normalize",
                                                     "outputbins=",
                                                     "gridbins=",
                                                     "smoothlen=",
                                                     "help"])
except getopt.GetoptError as err:
    # print help information and exit:
    print(str(err))  # will print something like "option -x not recognized"
    usage()
    sys.exit(2)

for o, a in opts:
    if o == "-x":
        print('got an x')
    elif o == "--glm":
        doglm = True
        print('will generate and remove aliased voxelwise cardiac regressors')
    elif o == "--disablenotch":
        notchwidth = -1.0
        print('Disabling subharmonic notch filter')
    elif o == "--nodetrend":
        detrend = False
        print('will disable data detrending')
    elif o == "--debug":
        debug = True
        print('extended debugging messages')
    elif o == "--outputbins":
        destpoints = int(a)
        print('will use', destpoints, 'output bins')
    elif o == "--smoothlen":
        smoothlen = int(a)
        smoothlen = smoothlen + (1 - smoothlen % 2)
        print('will set savitsky-golay window to', smoothlen)
    elif o == "--gridbins":
        congridbins = float(a)
        print('will set gridding kernel to', congridbins, 'bins')
    elif o == "--minhr":
        newval = float(a) / 60.0
        #if newval > arb_lower:
        print('will set bottom of cardiac band to', newval * 60.0, 'BPM from', arb_lower * 60.0, 'BPM')
        arb_lower = newval
    elif o == "--notchwidth":
        notchwidth = float(a) / 100.0
        print('setting notchwidth to', notchwidth * 100.0, '%')
    elif o == "--maxhr":
        newval = float(a) / 60.0
        #if newval < arb_upper:
        print('will set top of cardiac band to', newval * 60.0, 'BPM from', arb_upper * 60.0, 'BPM')
        arb_upper = newval
    elif o == "--normalize":
        fmrinorm = True
        print('will normalize fmri before gridding')
    elif o == '--cardiacfile':
        inputlist = a.split(':')
        cardiacfile = inputlist[0]
        if len(inputlist) > 1:
            try:
                colnum = int(inputlist[1])
            except:
                colname = inputlist[1]
        print('Will use cardiac file', cardiacfile)
    elif o == '--cardiacfreq':
        inputfreq = float(a)
        print('Setting cardiac sample frequency to ', inputfreq)
    elif o == '--cardiactstep':
        inputfreq = 1.0 / float(a)
        print('Setting cardiac sample time step to ', float(a))
    elif o == '--cardiacstart':
        inputstart = float(a)
        print('Setting cardiac start time to ', inputstart)
    elif o == "--help":
        usage()
        sys.exit()
    else:
        assert False, "unhandled option: " + o

memfile = open(outputroot + '_memusage.csv', 'w')
tide_util.logmem(None, file=memfile)

theprefilter = tide_filt.noncausalfilter()
theprefilter.settype('arb')
arb_lowerstop = arb_lower * 0.9
arb_upperstop = arb_upper * 1.1
theprefilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
infodict['filtermaxbpm'] = arb_upper * 60.0
infodict['filterminbpm'] = arb_lower * 60.0
infodict['notchwidthpct'] = notchwidth * 100.0
timings.append(['Argument parsing done', time.time(), None, None])


# read in the image data
tide_util.logmem('before reading in fmri data', file=memfile)
nim, nim_data, nim_hdr, thedims, thesizes = tide_io.readfromnifti(fmrifilename)
xsize, ysize, numslices, timepoints = tide_io.parseniftidims(thedims)
xdim, ydim, slicethickness, tr = tide_io.parseniftisizes(thesizes)
spaceunit, timeunit = nim_hdr.get_xyzt_units()
if timeunit == 'msec':
    tr /= 1000.0
mrsamplerate = 1.0 / tr
print('tr is', tr, 'seconds, mrsamplerate is', mrsamplerate)
numspatiallocs = int(xsize) * int(ysize) * int(numslices)
infodict['tr'] = tr
infodict['mrsamplerate'] = mrsamplerate
timings.append(['Image data read in', time.time(), None, None])

# remap to space by time
fmri_data = nim_data.reshape((numspatiallocs, timepoints))

# make and save a mask of the voxels to process
tide_util.logmem('before mask creation', file=memfile)
mask = np.uint16(tide.makemask(np.mean(fmri_data[:, :], axis=1),
                                       threshpct=maskthreshpct))
mask3d = mask.reshape((xsize, ysize, numslices))
theheader = nim_hdr
theheader['dim'][4] = 1
timings.append(['Mask created', time.time(), None, None])
tide_io.savetonifti(mask3d, theheader, thesizes, outputroot + '_mask')
timings.append(['Mask saved', time.time(), None, None])


# get slice times
filebase, extension = os.path.splitext(slicetimename)
if extension == '.json':
    jsoninfodict = tide_io.readbidssidecar(slicetimename)
    try:
        slicetimelist = jsoninfodict['SliceTiming']
        slicetimes = np.zeros((len(slicetimelist)), dtype=np.float64)
        for idx, thetime in enumerate(slicetimelist):
            slicetimes[idx] = float(thetime)
    except:
        print(slicetimename, 'is not a valid BIDS sidecar file')
        sys.exit()
else:
    slicetimes = tide_io.readvec(slicetimename)
timings.append(['Slice times determined', time.time(), None, None])

# now get an estimate of the cardiac signal
print('generating cardiac signal from fmri data')
tide_util.logmem('before cardiacfromimage', file=memfile)
cardiacfromfmri, slicesamplerate, numsteps = cardiacfromimage(fmri_data, mask, xsize, ysize, numslices, timepoints, tr, slicetimes, theprefilter, \
    notchwidth=notchwidth,
    detrend=detrend,
    debug=debug)
timings.append(['Cardiac signal generated from image data', time.time(), None, None])
slicetimeaxis = sp.linspace(0.0, tr * timepoints, num=(timepoints * numsteps), endpoint=False)
tide_io.writevec(cardiacfromfmri, outputroot + '_cardiacfromfmri.txt')
cardiacwaveform = cardiacfromfmri
infodict['slicesamplerate'] = slicesamplerate
infodict['numsteps'] = numsteps

# find key components of cardiac waveform
print('extracting harmonic components')
peakfreq_bold, amps_bold, phases_bold = getcardcoeffs(cardiacwaveform, slicesamplerate, smoothlen=smoothlen, debug=debug)
print('harmonic amplitudes:', amps_bold[0], amps_bold[1], amps_bold[2])
print('harmonic phases:', phases_bold[0], phases_bold[1], phases_bold[2])
infodict['cardiacpeakbpm_bold'] = np.round(peakfreq_bold * 60.0, 2)
infodict['kalminit_bold_cardiacfreq'] = peakfreq_bold
for i in range(len(amps_bold)):
    infodict['kalminit_bold_amp' + str(i)] = amps_bold[i]
    infodict['kalminit_bold_ph' + str(i)] = phases_bold[i]
timings.append(['Cardiac signal from image data analyzed', time.time(), None, None])

tide_io.writevec(tide.corrnormalize(tide_resample.arbresample(cardiacfromfmri, slicesamplerate, 100.0), False, False), outputroot + '_cardiacfromfmri_100Hz.txt')
timings.append(['Cardiac signal from image data resampled and saved', time.time(), None, None])

# get the cardiac signal from a file, if specified
if cardiacfile is not None:
    tide_util.logmem('before cardiacfromfile', file=memfile)
    print('reading cardiac signal from file')
    infodict['cardiacfromfmri'] = False
    # check file type
    filebase, extension = os.path.splitext(cardiacfile)
    if extension == '.json':
        inputfreq, inputstart, inputwave = tide_io.readcolfrombidstsv(cardiacfile, columnname=colname, columnnum=colnum)
    else:
        inputwave = np.transpose(tide_io.readvecs(cardiacfile))
        print(inputwave.shape)
        if len(inputwave.shape) != 1:
            inputwave = inputwave[:, colnum]
    inputtimeaxis = sp.arange(0.0, (1.0 / inputfreq) * len(inputwave), 1.0 / inputfreq) + inputstart
    if debug:
        print('inputwave: len=', len(inputwave), 'vals=', inputwave)
        print('inputfreq =', inputfreq)
        print('inputstart =', inputstart)
        print('inputtimeaxis: len=', len(inputtimeaxis), 'vals=', inputtimeaxis)
    cardiacfromfile = tide_resample.doresample(inputtimeaxis, inputwave, slicetimeaxis, method='cubic', padlen=0)
    cardiacfromfile = tide.corrnormalize(cardiacfromfile, False, False)
    timings.append(['Cardiac signal from physiology data read in', time.time(), None, None])

    # find key components of cardiac waveform
    peakfreq_file, amps_file, phases_file = getcardcoeffs(cardiacfromfile, slicesamplerate, smoothlen=smoothlen, debug=debug)
    infodict['cardiacpeakbpm_file'] = np.round(peakfreq_file * 60.0, 2)
    infodict['kalminit_file_cardiacfreq'] = peakfreq_file
    for i in range(len(amps_file)):
        infodict['kalminit_file_amp' + str(i)] = amps_file[i]
        infodict['kalminit_file_ph' + str(i)] = phases_file[i]
    timings.append(['Cardiac signal from physiology data analyzed', time.time(), None, None])

    tide_io.writevec(cardiacfromfile, outputroot + '_cardiacfromfile.txt')
    tide_io.writevec(tide.corrnormalize(tide_resample.arbresample(inputwave, inputfreq, 100.0), False, False), outputroot + '_cardiacfromfile_100Hz.txt')
    timings.append(['Cardiac signal from physiology data resampled and saved', time.time(), None, None])

    thexcorr = tide.fastcorrelate(cardiacfromfile, cardiacfromfmri, usefft=True)
    xcorrlen = len(thexcorr)
    sampletime = 1.0 / slicesamplerate
    xcorr_x = np.r_[0.0:xcorrlen] * sampletime - (xcorrlen * sampletime) / 2.0 + sampletime / 2.0
    maxdelay = xcorr_x[np.argmax(thexcorr)]
    searchrange = 10.0
    maxindex, maxdelay, maxval, maxsigma, maskval, failreason, peakstart, peakend = tide_fit.findmaxlag_gauss(
            xcorr_x, thexcorr, -searchrange, searchrange, 1000.0,
            refine=True,
            useguess=False,
            fastgauss=False,
            displayplots=False)
    print('Input cardiac waveform delay is', maxdelay, 'relative to fMRI data')
    print('Correlation coefficient between cardiac regressors:', maxval)
    cardiacwaveform = cardiacfromfile

    if doplot:
        figure()
        plot(slicetimeaxis, cardiacfromfile, 'r', slicetimeaxis, cardiacfromfmri, 'b')
        show()
    infodict['cardiacfromfile'] = True
    peakfreq = peakfreq_file
else:
    infodict['cardiacfromfile'] = False
    peakfreq = peakfreq_bold

# now tune the prefilter to hone in on the primary harmonic
arb_lower = 0.4 * peakfreq
arb_upper = 1.4 * peakfreq
arb_lowerstop = 0.9 * arb_lower
arb_upperstop = 1.1 * arb_upper
theprefilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
filthiresfund = tide.corrnormalize(theprefilter.apply(slicesamplerate, cardiacwaveform), False, False)
tide_io.writevec(filthiresfund, outputroot + '_cardiacfundamental.txt')

# account for slice time offests
offsets = nim_data[:, :, :, 0] * 0.0
for i in range(numslices):
    offsets[:, :, i] = slicetimes[i]

# remap to space by time
fmri_offsets = offsets.reshape((numspatiallocs))

# now calculate the phase waveform
tide_util.logmem('before analytic phase analysis', file=memfile)
analytic_signal = hilbert(filthiresfund)
amplitude_envelope = np.abs(analytic_signal)
instantaneous_phase = np.angle(analytic_signal / amplitude_envelope)
tide_io.writevec((analytic_signal / amplitude_envelope).real, outputroot + '_oscillatory.txt')
tide_io.writevec(amplitude_envelope, outputroot + '_ampenv.txt')
tide_io.writevec(instantaneous_phase, outputroot + '_instphase.txt')
instantaneous_phase = np.unwrap(instantaneous_phase)
tide_io.writevec(instantaneous_phase, outputroot + '_instphase_unwrapped.txt')
initialphase = instantaneous_phase[0]
infodict['kalminit_phi0'] = initialphase
timings.append(['Phase waveform generated', time.time(), None, None])

# Make synthetic cardiac files
gencardiac = tide.corrnormalize(amplitude_envelope * cardiacsig(instantaneous_phase, amps=amps_bold, phases=phases_bold), False, False)
tide_io.writevec(gencardiac, outputroot + '_synthcardiacfromfmri.txt')
timings.append(['Synthetic cardiac waveform generated', time.time(), None, None])

if infodict['cardiacfromfile']:
    gencardiac = tide.corrnormalize(amplitude_envelope * cardiacsig(instantaneous_phase, amps=amps_file, phases=phases_file), False, False)
    tide_io.writevec(gencardiac, outputroot + '_synthcardiacfromfile.txt')

# save the information file
tide_io.writedict(infodict, outputroot + '_info.txt')

# interpolate the instantaneous phase
upsampledslicetimeaxis = sp.linspace(0.0, tr * timepoints, num=(timepoints * numsteps * upsamplefac), endpoint=False)
interpphase = phasemod(tide_resample.doresample(slicetimeaxis, instantaneous_phase, upsampledslicetimeaxis, method='cubic', padlen=0))
tide_io.writevec(interpphase, outputroot + '_interpinstphase.txt')

# calculate RRI
therri = rrifromphase(upsampledslicetimeaxis, interpphase)

# find the phase values for all timepoints in all slices
phasevals = np.zeros((numslices, timepoints), dtype=np.float64)
for theslice in range(numslices):
    thetimes = sp.linspace(0.0, tr * timepoints, num=timepoints, endpoint=False) + slicetimes[theslice]
    phasevals[theslice, :] = phasemod(tide_resample.doresample(slicetimeaxis, instantaneous_phase, thetimes, method='cubic', padlen=0))
    if debug:
        tide_io.writevec(thetimes, outputroot + '_times_' + str(theslice).zfill(2) + '.txt')
        tide_io.writevec(phasevals[theslice, :], outputroot + '_phasevals_' + str(theslice).zfill(2) + '.txt')
timings.append(['Slice phases determined for all timepoints', time.time(), None, None])

# construct a destination array
tide_util.logmem('before making destination arrays', file=memfile)
app = np.zeros((xsize, ysize, numslices, destpoints), dtype=np.float64)
weights = np.zeros((xsize, ysize, numslices, destpoints), dtype=np.float64)
app_byslice = app.reshape((xsize * ysize, numslices, destpoints))
weight_byslice = weights.reshape((xsize * ysize, numslices, destpoints))
timings.append(['Output arrays allocated', time.time(), None, None])

# high pass filter to remove trends
imagingtime = tr * timepoints
phasefilter = tide_filt.noncausalfilter()
phasefilter.settype('arb')
arb_lower = 4.0 / imagingtime
arb_upper = 0.5 / tr
arb_lowerstop = arb_lower
arb_upperstop = arb_upper
phasefilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)

outphases = sp.linspace(-np.pi, np.pi - 0.000000000001, num=destpoints, endpoint=True)
outphasestep = outphases[1] - outphases[0]
phasestep = outphases[1] - outphases[0]
congridwidth = congridbins * phasestep

maskbyslice = mask3d.reshape((xsize * ysize, numslices))
if fmrinorm:
    fmri_data_byslice = normdata.reshape((xsize * ysize, numslices, timepoints))
else:
    fmri_data_byslice = nim_data.reshape((xsize * ysize, numslices, timepoints))
timings.append(['Phase projection to image started', time.time(), None, None])
for theslice in range(numslices):
    print('doing slice', theslice)
    validlocs = np.where(maskbyslice[:, theslice] > 0)[0]
    for t in range(timepoints):
        thevals, theweights, theindices = tide_resample.congrid(outphases, phasevals[theslice, t], 1.0, congridwidth)
        if detrend:
            filteredmr = -tide_fit.detrend(fmri_data_byslice[validlocs, theslice, t], demean=False)
        else:
            filteredmr = -fmri_data_byslice[validlocs, theslice, t]
        for i in range(len(theindices)):
            weight_byslice[validlocs, theslice, theindices[i]] += theweights[i]
            app_byslice[validlocs, theslice, theindices[i]] += theweights[i] * filteredmr
    app_byslice[validlocs, theslice, :] = \
        np.nan_to_num(app_byslice[validlocs, theslice, :] / weight_byslice[validlocs, theslice, :])
    slicemin = np.min(app_byslice[validlocs, theslice, :], axis=1).reshape((-1, 1))
    app_byslice[validlocs, theslice, :] -= slicemin
timings.append(['Phase projection to image completed', time.time(), None, None])

# save the analytic phase projection image
theheader = nim_hdr
theheader['dim'][4] = destpoints
theheader['toffset'] = -np.pi
theheader['pixdim'][4] = 2.0 * np.pi / destpoints
tide_io.savetonifti(app, theheader, thesizes, outputroot + '_app')
#tide_io.savetonifti(weights, theheader, thesizes, outputroot + '_weights')
timings.append(['Phase projected data saved', time.time(), None, None])

# make and save a voxel intensity histogram
app2d = app.reshape((numspatiallocs, destpoints))
validlocs = np.where(mask > 0)[0]
histinput = app2d[validlocs, :].reshape((len(validlocs), destpoints))
tide.makeandsavehistogram(histinput, histlen, 0, outputroot + '_histogram')

# make find vessel threshholds 
tide_util.logmem('before making vessel masks', file=memfile)
hardvesselthresh = tide.getfracvals(np.max(histinput, axis=1), [0.98])[0] / 2.0
softvesselthresh = softvesselfrac * hardvesselthresh
print('hard, soft vessel threshholds set to', hardvesselthresh, softvesselthresh)

# save a vessel masked version of app
vesselmask = np.where(np.max(app, axis=3) > softvesselthresh, 1, 0)
maskedapp2d = app2d + 0.0
maskedapp2d[np.where(vesselmask.reshape((numspatiallocs)) == 0)[0], :] = 0.0
tide_io.savetonifti(maskedapp2d.reshape((xsize, ysize, numslices, destpoints)), theheader, thesizes, outputroot + '_maskedapp')
maskedapp2d = None
timings.append(['Vessel masked phase projected data saved', time.time(), None, None])

# save multiple versions of the hard vessel mask
vesselmask = np.where(np.max(app, axis=3) > hardvesselthresh, 1, 0)
minphase = np.argmin(app, axis=3) * 2.0 * np.pi / destpoints - np.pi 
maxphase = np.argmax(app, axis=3) * 2.0 * np.pi / destpoints - np.pi
risediff = (maxphase - minphase) * vesselmask
arteries = np.where(risediff < 0, 1, 0)
veins = np.where(risediff > 0, 1, 0)
theheader = nim_hdr
theheader['dim'][4] = 1
tide_io.savetonifti(vesselmask, theheader, thesizes, outputroot + '_vesselmask')
tide_io.savetonifti(minphase, theheader, thesizes, outputroot + '_minphase')
tide_io.savetonifti(maxphase, theheader, thesizes, outputroot + '_maxphase')
tide_io.savetonifti(arteries, theheader, thesizes, outputroot + '_arteries')
tide_io.savetonifti(veins, theheader, thesizes, outputroot + '_veins')
timings.append(['Masks saved', time.time(), None, None])

# now generate aliased cardiac signals and regress them out of the data
if doglm:
    # generate the signals
    timings.append(['Cardiac signal regression started', time.time(), None, None])
    tide_util.logmem('before cardiac regression', file=memfile)
    print('generating cardiac regressors')
    cardiacnoise = fmri_data_byslice * 0.0
    for theslice in range(numslices):
        print('doing slice', theslice)
        validlocs = np.where(maskbyslice[:, theslice] > 0)[0]
        for t in range(timepoints):
            phaseindex = int(np.round((phasevals[theslice, t] - outphases[0]) / phasestep, 0))
            cardiacnoise[validlocs, theslice, t] = app_byslice[validlocs, theslice, phaseindex] * amplitude_envelope[t]
    theheader = nim_hdr
    tide_io.savetonifti(cardiacnoise.reshape((xsize, ysize, numslices, timepoints)), theheader, thesizes, outputroot + '_cardiacnoise')
    
    # now remove them
    tide_util.logmem('before cardiac removal', file=memfile)
    print('removing cardiac signal with GLM')
    filtereddata = 0.0 * fmri_data_byslice
    for theslice in range(numslices):
        print('doing slice', theslice)
        validlocs = np.where(maskbyslice[:, theslice] > 0)[0]
        for theloc in validlocs:
            lagtc = cardiacnoise[theloc, theslice, :]
            thefit, R = tide.mlregress(lagtc, fmri_data_byslice[theloc, theslice, :])
            fitcoff = thefit[0, 1]
            datatoremove = fitcoff * lagtc
            filtereddata[theloc, theslice, :] = fmri_data_byslice[theloc, theslice, :] - datatoremove
    theheader = nim_hdr
    tide_io.savetonifti(filtereddata.reshape((xsize, ysize, numslices, timepoints)), theheader, thesizes, outputroot + '_filtereddata')
    timings.append(['Cardiac signal regression finished', time.time(), None, None])

timings.append(['Done', time.time(), None, None])

# Process and save timing information
nodeline = 'Processed on ' + platform.node()
tide_util.proctiminginfo(timings, outputfile=outputroot + '_runtimings.txt', extraheader=nodeline)

tide_util.logmem('final', file=memfile)
