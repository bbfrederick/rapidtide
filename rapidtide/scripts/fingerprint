#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2021 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
import argparse
import copy
import os
import sys
from argparse import RawTextHelpFormatter

import numpy as np
import pandas as pd

import rapidtide.fit as tide_fit
import rapidtide.io as tide_io


def fingerprint_main(
    themapname,
    whichtemplate,
    whichatlas,
    outputroot,
    fitorder,
    themaskname=None,
    intercept=True,
    debug=False,
):
    # read the data
    referencedir = os.path.join(
        os.path.split(os.path.split(os.path.split(__file__)[0])[0])[0],
        "rapidtide",
        "data",
        "reference",
    )

    if whichtemplate == "lag":
        thetemplatename = os.path.join(referencedir, "HCP1200_lag_2mm.nii.gz")
    elif whichtemplate == "strength":
        thetemplatename = os.path.join(referencedir, "HCP1200_strength_2mm.nii.gz")
    elif whichtemplate == "sigma":
        thetemplatename = os.path.join(referencedir, "HCP1200_sigma_2mm.nii.gz")
    else:
        print("illegal template:", whichtemplate)
        sys.exit()

    if whichatlas == "ASPECTS":
        theatlasname = os.path.join(referencedir, "ASPECTS_2mm.nii.gz")
        theatlasregionsname = os.path.join(referencedir, "ASPECTS_regions.txt")
    elif whichatlas == "ATT":
        theatlasname = os.path.join(referencedir, "ATTbasedFlowTerritories_split_2mm.nii.gz")
        theatlasregionsname = os.path.join(
            referencedir, "ATTbasedFlowTerritories_split_regions.txt"
        )
    else:
        print("illegal atlas:", whichatlas)
        sys.exit()

    if debug:
        print(f"reading atlas file {theatlasname}")
    (
        thetemplate,
        thetemplate_data,
        thetemplate_hdr,
        thetemplatedims,
        thetemplatesizes,
    ) = tide_io.readfromnifti(thetemplatename)
    atlas, atlas_data, atlas_hdr, atlasdims, atlassizes = tide_io.readfromnifti(theatlasname)
    atlaslabelsinput = pd.read_csv(
        theatlasregionsname, delimiter="\t", header=None, names=["Region"]
    )

    if debug:
        print(f"reading map file {themapname}")
    (
        themap,
        themap_data,
        themap_hdr,
        themapdims,
        thetemplatesizes,
    ) = tide_io.readfromnifti(themapname)
    if themaskname is None:
        themask_data = None
    else:
        if debug:
            print(f"reading mask file {themaskname}")
        (
            themask,
            themask_data,
            themask_hdr,
            themaskdims,
            thetemplatesizes,
        ) = tide_io.readfromnifti(themaskname)

    # check for compatible dimensions
    if not tide_io.checkspacematch(thetemplate_hdr, themap_hdr):
        raise ValueError(f"Dimensions of {themapname} do not match the atlas dimensions - exiting")
    if themask_data is not None:
        if not tide_io.checkspacematch(themask_hdr, themap_hdr):
            raise ValueError(
                f"Dimensions of {themaskname} and {themapname} do not match - exiting"
            )

    # do the fit
    nx, ny, nz, nummaps = tide_io.parseniftidims(themapdims)
    if debug:
        print("starting decomposition")
    thefitmap, thecoffs, theRs = tide_fit.territorydecomp(
        themap_data,
        thetemplate_data,
        atlas_data.astype(int),
        nummaps,
        inputmask=themask_data,
        fitorder=fitorder,
        intercept=intercept,
        debug=debug,
    )

    # present the data
    numregions = len(atlaslabelsinput)
    if intercept:
        numcoffs = fitorder + 1
    else:
        numcoffs = fitorder
    R_array = np.zeros((numregions, nummaps), dtype="float")
    coff_array = np.zeros((numcoffs, numregions, nummaps), dtype="float")
    for whichmap in range(nummaps):
        atlaslabels = atlaslabelsinput.copy()
        R_array[:, whichmap] = theRs[whichmap]
        atlaslabels["R"] = theRs[whichmap]
        newcols = pd.DataFrame(thecoffs[whichmap, :, :])
        coff_array[:, :, whichmap] = np.transpose(thecoffs[whichmap, :, :])
        columnnames = []
        if intercept:
            startpt = 0
        else:
            startpt = 1
        for i in range(startpt, fitorder + 1):
            columnnames += str(i)
        newcols.columns = columnnames
        atlaslabels = pd.concat([atlaslabels, newcols], axis=1)
        atlaslabels.to_csv(f"{outputroot}_{str(whichmap).zfill(4)}_fits.tsv", sep="\t")
        if debug:
            print(atlaslabels)

    # save the Rs as tsv
    newcols = pd.DataFrame(np.transpose(R_array[:, :]))
    newcols.columns = atlaslabelsinput["Region"]
    newcols.to_csv(f"{outputroot}_allRs.tsv", index=False, sep="\t")

    # save the fits
    if intercept:
        startpt = 0
    else:
        startpt = 1
    for i in range(startpt, fitorder + 1):
        newcols = pd.DataFrame(np.transpose(coff_array[i, :, :]))
        newcols.columns = atlaslabelsinput["Region"]
        newcols.to_csv(f"{outputroot}_fit_O{str(i)}.tsv", index=False, sep="\t")

    # save the fit data
    tide_io.savetonifti(thefitmap, themap_hdr, outputroot + "_fit")
    maskmap = 0.0 * themap_data[:, :, :, 0]
    maskmap[np.where(atlas_data > 0)] = 1.0

    # save the fit error
    diffmap = (themap_data - thefitmap) * maskmap[:, :, :, None]
    tide_io.savetonifti(diffmap, themap_hdr, outputroot + "_fitdiff")

    # save the Rs as nifti
    thehdr = copy.deepcopy(themap_hdr)
    print(f"shape of R_array: {R_array.shape}")
    print(f"thehdr before: {thehdr['dim']}")
    thehdr["dim"][0] = 2
    thehdr["dim"][1] = R_array.shape[0]
    thehdr["dim"][2] = R_array.shape[1]
    thehdr["dim"][3] = 1
    thehdr["dim"][4] = 1
    print(f"thehdr after: {thehdr['dim']}")
    thehdr["pixdim"][0] = 1.0
    thehdr["pixdim"][1] = 1.0
    thehdr["pixdim"][2] = 1.0
    thehdr["pixdim"][3] = 1.0
    thehdr["pixdim"][4] = 1.0
    tide_io.savetonifti(R_array, thehdr, outputroot + "_allRs")

    # save the fits as nifti
    thehdr = copy.deepcopy(themap_hdr)
    print(f"shape of coff_array: {coff_array.shape}")
    print(f"thehdr before: {thehdr['dim']}")
    thehdr["dim"][0] = 3
    thehdr["dim"][1] = coff_array.shape[0]
    thehdr["dim"][2] = coff_array.shape[1]
    thehdr["dim"][3] = coff_array.shape[2]
    thehdr["dim"][4] = 1
    print(f"thehdr after: {thehdr['dim']}")
    thehdr["pixdim"][0] = 1.0
    thehdr["pixdim"][1] = 1.0
    thehdr["pixdim"][2] = 1.0
    thehdr["pixdim"][3] = 1.0
    thehdr["pixdim"][4] = 1.0
    tide_io.savetonifti(coff_array, thehdr, outputroot + "_allcoffs")


if __name__ == "__main__":

    class FullPaths(argparse.Action):
        """Expand user- and relative-paths"""

        def __call__(self, parser, namespace, values, option_string=None):
            if values == "":
                setattr(namespace, self.dest, "__EMPTY__")
            else:
                setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

    def is_dir(dirname):
        """Checks if a path is an actual directory"""
        if not os.path.isdir(dirname):
            msg = "{0} is not a directory".format(dirname)
            raise argparse.ArgumentTypeError(msg)
        else:
            return dirname

    def is_file(filename):
        """Checks if a file exists"""
        if not os.path.exists(filename):
            msg = "{0} does not exist".format(filename)
            raise argparse.ArgumentTypeError(msg)
        else:
            return filename

    parser = argparse.ArgumentParser(
        description=(
            "Fit a rapidtide output map to a canonical delay map, by vascular territory.\n"
        ),
        formatter_class=RawTextHelpFormatter,
    )

    parser.add_argument(
        "inputfile",
        help="rapidtide output map to decompose by vascular territory",
        action=FullPaths,
        type=is_file,
    )

    parser.add_argument(
        "outputroot",
        help="name root for output files",
        action=FullPaths,
        type=str,
    )

    parser.add_argument(
        "--maskname",
        help="mask defining voxels with valid values",
        type=is_file,
        default=None,
    )

    parser.add_argument(
        "--atlas",
        help="Atlas.  Options are\n"
        "\tASPECTS:  ASPECTS territory atlas\n"
        "\tATT:      Arterial transit time flow territories\n",
        default="ASPECTS",
    )

    parser.add_argument(
        "--fitorder",
        help="order of polynomial fit to template (default is 1).",
        type=int,
        default=1,
    )

    parser.add_argument(
        "--nointercept",
        help="do not use the zeroth order component when fitting",
        action="store_true",
    )

    parser.add_argument(
        "--template",
        help="Template.  Options are\n"
        "\tlag:      time lag in seconds\n"
        "\tstrength: correlation coefficient\n"
        "\tsigma:    correlation peak width in seconds\n",
        default="lag",
    )

    parser.add_argument(
        "--debug",
        help="output additionnal debugging information",
        action="store_true",
    )

    args = parser.parse_args()
    if args.debug:
        print(args)

    fingerprint_main(
        args.inputfile,
        args.template,
        args.atlas,
        args.outputroot,
        args.fitorder,
        intercept=not (args.nointercept),
        themaskname=args.maskname,
        debug=args.debug,
    )
