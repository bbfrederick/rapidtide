#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#   Copyright 2016-2024 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
import argparse
import copy

import numpy as np
from tqdm import tqdm

import rapidtide.correlate as tide_corr
import rapidtide.io as tide_io
import rapidtide.miscmath as tide_math
import rapidtide.resample as tide_resample
import rapidtide.stats as tide_stats
import rapidtide.workflows.parser_funcs as pf

DEFAULT_NUMSPACESTEPS = 1
DEFAULT_NPASSES = 20
DEFAULT_RADIUS = 10.5
DEFAULT_WINDOW_TYPE = "hamming"
DEFAULT_DETREND_ORDER = 3


def getcorrloc(thedata, idx1, idx2, Fs, negsearch=10.0, possearch=10.0, padding=0, debug=False):
    tc1 = thedata[idx1, :]
    tc2 = thedata[idx2, :]
    if np.any(tc1) != 0.0 and np.any(tc2) != 0.0:
        if debug:
            print(f"{idx1=}, {idx2=}")
            print(f"{tc1=}")
            print(f"{tc2=}")

        thesimfunc = tide_corr.fastcorrelate(
            tc1,
            tc2,
            zeropadding=padding,
            usefft=True,
            debug=debug,
        )
        similarityfunclen = len(thesimfunc)
        similarityfuncorigin = similarityfunclen // 2 + 1

        negpoints = int(negsearch / Fs)
        pospoints = int(possearch / Fs)
        trimsimfunc = thesimfunc[
            similarityfuncorigin - negpoints : similarityfuncorigin + pospoints
        ]
        offset = 0.0
        trimtimeaxis = (
            (
                np.arange(0.0, similarityfunclen) * (1.0 / Fs)
                - ((similarityfunclen - 1) * (1.0 / Fs)) / 2.0
            )
            - offset
        )[similarityfuncorigin - negpoints : similarityfuncorigin + pospoints]
        maxtime = trimtimeaxis[np.argmax(trimsimfunc)]
        maxval = np.max(trimsimfunc)
        if debug:
            print(f"{maxtime=}")
            print(f"{maxval=}")
            print(f"{negsearch=}")
            print(f"{possearch=}")
            print(f"{Fs=}")
            print(f"{len(trimtimeaxis)=}")
            print(trimsimfunc, trimtimeaxis)
        return maxval, maxtime, 1
    else:
        return 0.0, 0.0, 0


def xyz2index(x, y, z, ysize, zsize):
    return int(z) + int(y) * int(zsize) + int(x) * int(zsize * ysize)


def index2xyz(theindex, ysize, zsize):
    x = theindex // int(zsize * ysize)
    theindex -= int(x) * int(zsize * ysize)
    y = theindex // int(zsize)
    theindex -= int(y) * int(zsize)
    z = theindex
    return x, y, z


def main():
    # set default variable values
    displayplots = False

    # get the command line parameters
    parser = argparse.ArgumentParser(
        prog="localflow",
        description="Calculate local sources of signal.",
        allow_abbrev=False,
    )
    parser.add_argument("inputfilename", type=str, help="The name of the input nifti file.")
    parser.add_argument("outputroot", type=str, help="The root name of the output nifti files.")

    parser.add_argument(
        "--npasses",
        dest="npasses",
        type=int,
        help=f"The number of passes for reconstruction.  Default is {DEFAULT_NPASSES}",
        default=DEFAULT_NPASSES,
    )
    parser.add_argument(
        "--radius",
        dest="radius",
        type=float,
        help=f"The radius around the voxel to check correlations.  Default is {DEFAULT_RADIUS}",
        default=DEFAULT_RADIUS,
    )
    parser.add_argument(
        "--oversampfac",
        dest="oversampfactor",
        action="store",
        type=int,
        metavar="OVERSAMPFAC",
        help=(
            "Oversample the fMRI data by the following "
            "integral factor.  Set to -1 for automatic selection (default)."
        ),
        default=-1,
    )

    parser.add_argument(
        "--detrendorder",
        dest="detrendorder",
        action="store",
        type=int,
        metavar="ORDER",
        help=(f"Set order of trend removal (0 to disable). Default is {DEFAULT_DETREND_ORDER}."),
        default=DEFAULT_DETREND_ORDER,
    )
    parser.add_argument(
        "--nosphere",
        dest="dosphere",
        action="store_false",
        help=("Use rectangular rather than spherical reconstruction kernel."),
        default=True,
    )

    pf.addfilteropts(parser, filtertarget="data and regressors", details=True)
    pf.addwindowopts(parser, windowtype=DEFAULT_WINDOW_TYPE)

    misc = parser.add_argument_group("Miscellaneous options")
    misc.add_argument(
        "--noprogressbar",
        dest="showprogressbar",
        action="store_false",
        help=("Will disable showing progress bars (helpful if stdout is going " "to a file)."),
        default=True,
    )
    misc.add_argument(
        "--debug",
        dest="debug",
        action="store_true",
        help="Turn on debugging information.",
        default=False,
    )

    # get the command line parameters
    try:
        args = parser.parse_args()
    except SystemExit:
        parser.print_help()
        raise

    # postprocess filter options
    theobj, theprefilter = pf.postprocessfilteropts(args)

    # get the input TR
    inputtr_fromfile, numinputtrs = tide_io.fmritimeinfo(args.inputfilename)
    print("input data: ", numinputtrs, " timepoints, tr = ", inputtr_fromfile)

    input_img, fmridata, input_hdr, thedims, thesizes = tide_io.readfromnifti(args.inputfilename)
    if input_hdr.get_xyzt_units()[1] == "msec":
        tr = thesizes[4] / 1000.0
    else:
        tr = thesizes[4]
    Fs = 1.0 / tr
    print("tr from header =", tr, ", sample frequency is ", Fs)

    xsize, ysize, numslices, timepoints = tide_io.parseniftidims(thedims)
    xdim, ydim, slicethickness, tr = tide_io.parseniftisizes(thesizes)

    numspatiallocs = int(xsize) * int(ysize) * int(numslices)
    fmridata_voxbytime = fmridata.reshape((numspatiallocs, timepoints))
    if args.debug:
        print(f"{fmridata.shape=}")
        print(f"{fmridata_voxbytime.shape=}")

    # make a mask
    meanim = np.mean(fmridata, axis=3)
    themask = np.uint16(tide_stats.makemask(meanim, threshpct=0.1))
    themask_byvox = themask.reshape((numspatiallocs))
    numvalid = len(np.where(themask > 0)[0])
    print(f"{numvalid} valid")
    output_hdr = copy.deepcopy(input_hdr)
    output_hdr["dim"][4] = 1
    tide_io.savetonifti(
        themask,
        output_hdr,
        f"{args.outputroot}_mask",
        debug=args.debug,
    )

    # prepare the input data
    if args.oversampfactor == -1:
        oversamplefactor = int(np.max([np.ceil(tr / 0.5), 1]))
    else:
        oversamplefactor = args.oversampfactor
    print(f"using an oversample factor of {oversamplefactor}")
    initial_fmri_x = np.arange(0.0, timepoints) * tr
    oversamptr = tr / oversamplefactor
    os_fmri_x = np.arange(0.0, timepoints * oversamplefactor - (oversamplefactor - 1))
    os_fmri_x *= oversamptr
    ostimepoints = len(os_fmri_x)
    osfmridata = np.zeros((xsize, ysize, numslices, ostimepoints), dtype=float)
    osfmridata_voxbytime = osfmridata.reshape((numspatiallocs, ostimepoints))
    print("Preparing data")
    for thevoxel in tqdm(
        range(0, numspatiallocs),
        desc="Voxel",
        unit="voxels",
        disable=(not args.showprogressbar),
    ):
        if themask_byvox[thevoxel] > 0:
            osfmridata_voxbytime[thevoxel, :] = tide_resample.doresample(
                initial_fmri_x,
                tide_math.corrnormalize(
                    theprefilter.apply(Fs, fmridata_voxbytime[thevoxel, :]),
                    detrendorder=args.detrendorder,
                    windowfunc=args.windowfunc,
                ),
                os_fmri_x,
                padlen=int((1.0 / oversamptr) * args.padseconds),
            )
    output_hdr = copy.deepcopy(input_hdr)
    output_hdr["dim"][4] = ostimepoints
    output_hdr["pixdim"][4] = oversamptr
    tide_io.savetonifti(
        osfmridata_voxbytime.reshape((xsize, ysize, numslices, ostimepoints)),
        output_hdr,
        f"{args.outputroot}_preprocdata",
        debug=args.debug,
    )

    # make list of neighbors
    args.dosphere = True
    xsteps = int(np.ceil(args.radius / xdim))
    ysteps = int(np.ceil(args.radius / ydim))
    zsteps = int(np.ceil(args.radius / slicethickness))

    neighborlist = []
    distancelist = []
    for z in range(-zsteps, zsteps + 1):
        for y in range(-ysteps, ysteps + 1):
            for x in range(-xsteps, xsteps + 1):
                if args.dosphere:
                    distance = np.sqrt(
                        np.square(x * xdim) + np.square(y * ydim) + np.square(z * slicethickness)
                    )
                    if (x != 0 or y != 0 or z != 0) and distance <= args.radius:
                        neighborlist.append((x, y, z))
                        distancelist.append(distance)
                else:
                    if x != 0 or y != 0 or z != 0:
                        neighborlist.append((x, y, z))
    neighborarray = np.asarray(neighborlist, dtype=int)
    tide_io.writenpvecs(np.transpose(np.asarray(neighborlist)), f"{args.outputroot}_neighbors")
    if args.debug:
        print(f"{len(neighborlist)=}, {neighborlist=}")

    corrcoeffs = np.zeros((xsize, ysize, numslices, len(neighborlist)), dtype=float)
    delays = np.zeros((xsize, ysize, numslices, len(neighborlist)), dtype=float)
    corrvalid = np.zeros((xsize, ysize, numslices, len(neighborlist)), dtype=int)
    corrcoeffs3d = np.zeros(
        (2 * xsteps + 1, 2 * ysteps + 1, 2 * zsteps + 1, numvalid), dtype=float
    )
    targetdelay = np.zeros((xsize, ysize, numslices, args.npasses), dtype=float)
    delays3d = np.zeros((2 * xsteps + 1, 2 * ysteps + 1, 2 * zsteps + 1, numvalid), dtype=float)
    corrvalid3d = np.zeros((2 * xsteps + 1, 2 * ysteps + 1, 2 * zsteps + 1, numvalid), dtype=int)
    if args.debug:
        print(f"{corrcoeffs.shape=}, {delays.shape=}, {corrvalid.shape=}")
        printfirstdetails = True
    else:
        printfirstdetails = False

    # calculate temporal relationships
    indexlist = []
    theindex = 0
    for z in tqdm(
        range(zsteps, numslices - zsteps),
        desc="Slice",
        unit="slices",
        disable=(not args.showprogressbar),
    ):
        for y in range(ysteps, ysize - ysteps):
            for x in range(xsteps, xsize - xsteps):
                if themask[x, y, z] > 0:
                    index1 = xyz2index(x, y, z, ysize, numslices)
                    for idx, neighbor in enumerate(neighborlist):
                        if themask[x + neighbor[0], y + neighbor[1], z + neighbor[2]] > 0:
                            index2 = xyz2index(
                                x + neighbor[0],
                                y + neighbor[1],
                                z + neighbor[2],
                                ysize,
                                numslices,
                            )
                            (
                                corrcoeffs[x, y, z, idx],
                                delays[x, y, z, idx],
                                corrvalid[x, y, z, idx],
                            ) = getcorrloc(
                                osfmridata_voxbytime,
                                index1,
                                index2,
                                oversamplefactor * Fs,
                                debug=printfirstdetails,
                            )
                            corrcoeffs3d[
                                neighbor[0] + xsteps,
                                neighbor[1] + ysteps,
                                neighbor[2] + zsteps,
                                theindex,
                            ] = corrcoeffs[x, y, z, idx]
                            delays3d[
                                neighbor[0] + xsteps,
                                neighbor[1] + ysteps,
                                neighbor[2] + zsteps,
                                theindex,
                            ] = delays[x, y, z, idx]
                            corrvalid3d[
                                neighbor[0] + xsteps,
                                neighbor[1] + ysteps,
                                neighbor[2] + zsteps,
                                theindex,
                            ] = corrvalid[x, y, z, idx]
                        else:
                            corrvalid[x, y, z, idx] = 0
                    theindex += 1
                    indexlist.append(index1)
    tide_io.writenpvecs(np.transpose(np.asarray(indexlist)), f"{args.outputroot}_indexlist")

    # now reconstruct
    gain = 1.0
    targetdelay[:, :, :, 0] = 10.0 * (np.random.random((xsize, ysize, numslices)) - 0.5)
    for thepass in tqdm(
        range(1, args.npasses), desc="Pass", unit="passes", disable=(not args.showprogressbar)
    ):
        for thearrayindex, thecoordindex in enumerate(indexlist):
            x, y, z = index2xyz(thecoordindex, ysize, numslices)
            theseneighbors = neighborarray + np.array([x, y, z])
            deltasum = 0.0
            numneighbors = 0
            for whichneighbor in range(theseneighbors.shape[1]):
                if (
                    corrvalid3d[
                        neighborarray[whichneighbor, 0] + xsteps,
                        neighborarray[whichneighbor, 1] + ysteps,
                        neighborarray[whichneighbor, 2] + zsteps,
                        thearrayindex,
                    ]
                    > 0
                ):
                    thediff = (
                        delays3d[
                            neighborarray[whichneighbor, 0] + xsteps,
                            neighborarray[whichneighbor, 1] + ysteps,
                            neighborarray[whichneighbor, 2] + zsteps,
                            thearrayindex,
                        ]
                        - targetdelay[x, y, z, thepass - 1]
                    )
                    thenorm = corrcoeffs3d[
                        neighborarray[whichneighbor, 0] + xsteps,
                        neighborarray[whichneighbor, 1] + ysteps,
                        neighborarray[whichneighbor, 2] + zsteps,
                        thearrayindex,
                    ]
                    numneighbors += 1
                    deltasum += thediff * thenorm * thenorm
                if numneighbors > 0:
                    targetdelay[x, y, z, thepass] = (
                        gain * targetdelay[x, y, z, thepass - 1] + deltasum / numneighbors
                    )
                    # print(f"{deltasum}")

    output_hdr = copy.deepcopy(input_hdr)
    output_hdr["dim"][4] = args.npasses
    tide_io.savetonifti(
        targetdelay,
        output_hdr,
        f"{args.outputroot}_targetdelay",
        debug=args.debug,
    )

    output_hdr = copy.deepcopy(input_hdr)
    output_hdr["dim"][4] = len(neighborlist)
    tide_io.savetonifti(
        corrcoeffs,
        output_hdr,
        f"{args.outputroot}_corrcoeffs",
        debug=args.debug,
    )
    tide_io.savetonifti(
        delays,
        output_hdr,
        f"{args.outputroot}_delays",
        debug=args.debug,
    )
    tide_io.savetonifti(
        corrvalid,
        output_hdr,
        f"{args.outputroot}_corrvalid",
        debug=args.debug,
    )


if __name__ == "__main__":
    main()
