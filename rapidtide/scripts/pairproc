#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2021 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
import argparse

import numpy as np
from scipy.stats import pearsonr

import rapidtide.io as tide_io
import rapidtide.util as tide_util
from rapidtide.workflows.parser_funcs import is_valid_file


def main():
    parser = argparse.ArgumentParser(
        prog="pairproc",
        description="Compare the even and odd volumes of a 4D nifti file.",
        usage="%(prog)s inputfile outputroot",
    )

    parser.add_argument("inputfile", help="The name of the input nifti file, including extension")
    parser.add_argument("outputroot", help="The base name of the output files")

    # Optional arguments
    parser.add_argument(
        "--dmask",
        dest="datamaskname",
        type=lambda x: is_valid_file(parser, x),
        action="store",
        metavar="DATAMASK",
        help=("Use DATAMASK to specify which voxels in the data to use."),
        default=None,
    )
    parser.add_argument(
        "--debug", action="store_true", help="Print debugging information", default=False,
    )

    args = parser.parse_args()

    # read in the data files
    print("reading input file")
    input_img, input_data, input_hdr, thedims, thesizes = tide_io.readfromnifti(args.inputfile)
    xsize, ysize, numslices, timepoints = tide_io.parseniftidims(thedims)
    if args.debug:
        print(f"inputshape: {input_data.shape}")
    if timepoints % 2 != 0:
        raise ValueError("pairproc requires an even number of points in the time dimension")

    if args.datamaskname is not None:
        (
            datamask_img,
            datamask_data,
            datamask_hdr,
            datamaskdims,
            datamasksizes,
        ) = tide_io.readfromnifti(args.datamaskname)

    # check dimensions
    if args.datamaskname is not None:
        print("checking mask dimensions")
        if not tide_io.checkspacedimmatch(thedims, args.datamaskdims):
            print("input mask spatial dimensions do not match image")
            exit()
        if datamaskdims[4] != 1:
            print("input mask must have a time dimension of 1")
            exit()

    # allocating arrays
    print("reshaping arrays")
    numspatiallocs = int(xsize) * int(ysize) * int(numslices)
    rs_datafile = input_data.reshape((numspatiallocs, timepoints))

    print("masking arrays")
    if args.datamaskname is not None:
        proclocs = np.where(datamask_data.reshape(numspatiallocs) > 0.5)
    else:
        themaxes = np.max(rs_datafile, axis=1)
        themins = np.min(rs_datafile, axis=1)
        thediffs = (themaxes - themins).reshape(numspatiallocs)
        proclocs = np.where(thediffs > 0.0)
    procdata = rs_datafile[proclocs, :][0]
    numvalid = len(proclocs)
    print(rs_datafile.shape, procdata.shape)

    # make the output array
    evenims = procdata[:, 0:timepoints:2]
    oddims = procdata[:, 1 : timepoints + 1 : 2]
    if args.debug:
        print(f"evenshape: {evenims.shape}")
        print(f"oddshape: {oddims.shape}")

    numsubjects = timepoints // 2

    # cycle over all voxels
    reportstep = 1000
    print("Calculating temporal correlation over all voxels")
    temporalcorrelations = np.zeros((numvalid), dtype=float)
    temporalpvalues = np.zeros((numvalid), dtype=float)
    for vox in range(numvalid):
        temporalcorrelations[vox], temporalpvalues[vox] = pearsonr(evenims[vox, :], oddims[vox, :])
        if vox % reportstep == 0 or vox == numvalid - 1:
            tide_util.progressbar(vox + 1, numvalid, label="Percent complete")
    print()

    outarray = np.zeros((xsize, ysize, numslices), dtype=float)
    temporal_hdr = input_hdr.copy()
    temporal_hdr["pixdim"][4]
    outarray.reshape((numspatiallocs))[proclocs] = temporalcorrelations
    tide_io.savetonifti(outarray, temporal_hdr, f"{args.outputroot}_temporalcorralations")
    outarray.reshape((numspatiallocs))[proclocs] = temporalpvalues
    tide_io.savetonifti(outarray, temporal_hdr, f"{args.outputroot}_temporalpvalues")

    # cycle over all timepoints
    reportstep = 10
    print("Calculating spatial correlation over all subjects")
    spatialcorrelations = np.zeros((numsubjects), dtype=float)
    spatialpvalues = np.zeros((numsubjects), dtype=float)
    for subject in range(numsubjects):
        spatialcorrelations[subject], spatialpvalues[subject] = pearsonr(
            evenims[:, subject], oddims[:, subject]
        )
        if subject % reportstep == 0 or subject == numsubjects - 1:
            tide_util.progressbar(vox + 1, numsubjects, label="Percent complete")
    print()

    tide_io.writenpvecs(spatialcorrelations, f"{args.outputroot}_r1r2spatialcorrelations.txt")
    tide_io.writenpvecs(spatialpvalues, f"{args.outputroot}_r1r2spatialpvalues.txt")


if __name__ == "__main__":
    main()
